package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.33

import (
	"context"
	"fmt"
	"t-board/internal/controller/http/graphql/directives"
	"t-board/internal/controller/http/graphql/graph/model"
	"t-board/internal/entity"
)

// CreateBoard is the resolver for the createBoard field.
func (r *mutationResolver) CreateBoard(ctx context.Context, input model.CreateBoard) (*model.Board, error) {
	currentUser := ctx.Value(directives.AuthKey(directives.Key)).(string)
	user, err := r.userUseCase.Get(ctx, currentUser)
	if err != nil {
		return nil, err
	}

	creteBoardEntity := &entity.Board{
		Title:       input.Title,
		Description: input.Description,
		Members:     []string{user.ID},
		Type:        entity.BoardType(input.Type),
		OwnerID:     user.ID,
	}
	board, err := r.boardUseCase.Create(ctx, creteBoardEntity)
	if err != nil {
		return nil, err
	}

	if err = r.userUseCase.AddBoard(ctx, user, board); err != nil {
		return nil, err
	}

	return r.boardTransformer.TransformToModel(board), nil
}

// AddUserToBoard is the resolver for the addUserToBoard field.
func (r *mutationResolver) AddUserToBoard(ctx context.Context, user string, board string) (*model.Board, error) {
	currentUser := ctx.Value(directives.AuthKey(directives.Key)).(string)
	b, err := r.boardUseCase.GetOneByOwner(ctx, board, currentUser)
	if err != nil {
		return nil, err
	}

	u, err := r.userUseCase.Get(ctx, user)
	if err != nil {
		return nil, err
	}

	if err := r.userUseCase.AddBoard(ctx, u, b); err != nil {
		return nil, err
	}

	if err := r.boardUseCase.AddUser(ctx, u, b); err != nil {
		return nil, err
	}

	return r.boardTransformer.TransformToModel(b), nil
}

// DeleteBoard is the resolver for the deleteBoard field.
func (r *mutationResolver) DeleteBoard(ctx context.Context, board string) (*bool, error) {
	currentUser := ctx.Value(directives.AuthKey(directives.Key)).(string)
	b, err := r.boardUseCase.GetOneByOwner(ctx, board, currentUser)
	if err != nil {
		return nil, err
	}

	if err := r.boardUseCase.Delete(ctx, b.ID); err != nil {
		return nil, err
	}

	if err := r.userUseCase.DeleteBoardFromUsers(ctx, board); err != nil {
		return nil, err
	}
	result := true

	return &result, nil
}

// ClearBoard is the resolver for the clearBoard field.
func (r *mutationResolver) ClearBoard(ctx context.Context, board string) (*bool, error) {
	panic(fmt.Errorf("not implemented: ClearBoard - clearBoard"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	currentUser := ctx.Value(directives.AuthKey(directives.Key)).(string)
	user, err := r.userUseCase.Get(ctx, currentUser)
	if err != nil {
		return nil, err
	}

	m := r.userTransformer.TransformToModel(user)

	return m, nil
}

// GetBoards is the resolver for the getBoards field.
func (r *queryResolver) GetBoards(ctx context.Context) ([]*model.Board, error) {
	currentUser := ctx.Value(directives.AuthKey(directives.Key)).(string)
	user, err := r.userUseCase.Get(ctx, currentUser)
	if err != nil {
		return nil, err
	}

	var boards []*model.Board
	boardsEntity, err := r.boardUseCase.GetByUser(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	for _, board := range boardsEntity {
		m := r.boardTransformer.TransformToModel(board)

		boards = append(boards, m)
	}

	return boards, nil
}

// GetBoard is the resolver for the getBoard field.
func (r *queryResolver) GetBoard(ctx context.Context, board string) (*model.Board, error) {
	panic(fmt.Errorf("not implemented: GetBoard - getBoard"))
}

// GetNotesByBoard is the resolver for the getNotesByBoard field.
func (r *queryResolver) GetNotesByBoard(ctx context.Context, board string) ([]*model.Note, error) {
	panic(fmt.Errorf("not implemented: GetNotesByBoard - getNotesByBoard"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
